%Analyse <..> for the purpose of <..> with respect to their <..> from the point of view of the <..> in the context of <..>
\iffalse \bibliography{include/backmatter/magnus,include/backmatter/philip} \fi
\chapter{Methodology}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experiment Planning}
% all information that is necessary to replicate the study 
To answer the research questions, an experiment is carried out following the guidelines presented by Jedlitschka et al. \cite{Andreas}. All material for the experiment is available online\footnote{github.com/Pletron/ODVpi}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Goals}
% refine the main research questions, describe and motivate them to allow for traceability down to the hypotheses. 
%How does the respective execution context influence the scheduling precision of the respective application?
%How does the respective execution context influence the input/output performance of the respective application?


The aim of the experiment is to systematically evaluate the scheduling precision of the experimental units running in different execution environments. The goals of the experiment are described in table~\ref{table:exp-goals}, where the experimental units, execution environment and system load is described further in this section.  

% execution environment: complete system 
% deployment context: docker non-docker 

\begin{table}[ht]
\begin{tabular}{l|p{12cm}}
Goal 1 & Analyse the scheduling precision of the Pi Component for the purpose of understanding how deterministic the system is with respect to the execution environment and system load. \\
Goal 2 & Analyse the input and output performance of the Pi/IO Component for the purpose of understanding how deterministic the system is with respect to the execution environment and system load.
\end{tabular}
\centering
\caption{Experiment Goals}
\label{table:exp-goals}
\end{table}


\subsubsection{Execution Environment}
The execution environment describes the context in which the execution of the experimental units take place. Specifically, the execution environment is the configuration of the target system, where an alternation between Linux kernels and an alternation between deployment contexts take place. The deployment context refers to the runtime context of the experimental units. The deployment context is either running the experimental units in a Docker container or running the experimental units \textit{natively} on the target system. The execution environments are precisely specified in table~\ref{table:exe-env}.

\begin{table}[ht]
\begin{tabular}{l|p{14cm}}
1. & Running the experimental units natively on the target system running a mainline vanilla Linux kernel.                               \\
2. & Running the experimental units natively on the target system running a mainline Linux kernel patched with RT\_PREEMPT.              \\
3. & Running the experimental units in a Docker container on the target system running a mainline vanilla Linux kernel.                  \\
4. & Running the experimental units in a Docker container on the target system running a mainline Linux kernel patched with RT\_PREEMPT.
\end{tabular}
\centering
\caption{Execution Environments}
\label{table:exe-env}
\end{table}


\subsubsection{System Load}
Tracing through all possible code paths of the kernel is not an option to uncover how deterministic a system is. In order to get a reliable estimation, a tool is required to traverse as many of these as possible. Stress offers a way to induce several different kinds of system load, therefore it interacts with many components of the kernel and should be able to expose some of the longer code paths through the kernel. Stress is a user-space application that can spawn a number of worker threads that perform useless tasks with the only purpose of submitting the system on which it runs to heavy load. Putting the system under load also enables the experiment to be executed in an environment that mimics a real-life scenario. One would expect a computer system in production to run at 80\% load, leaving a 20\% buffer for extreme circumstances and to avoid overloading the system.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experimental Units}
\label{section:exp-units}
% participants (experimental units) need to be described in detail. Sampling strategy, the number of participants, the kind of participants and the population they were drawn from. 

The experimental units consist of two components that have be realised by utilising the open source library OpenDaVINCI \cite{OpenDaVINCI}. OpenDaVINCI is a development architecture of virtual, networked and cyber-physical infrastructures and has been used to realise a number of self-driving vehicles through research projects in academia \cite{OpenDaVINCI}. Using OpenDaVINCI as a development architecture for the experimental units allows the experiment to mimic the middleware one can expect in a autonomous vehicle. The implementation of OpenDaVINCI has been altered to enable full measurement of the system during runtime. Further extensions were made to make sure the measurements were as precise as possible by enabling nanosecond precision. Lastly, Timestamp was altered to enable writing the data of the measurement points to a serial port, the code added can be found in the appendix \ref{code:serialtime}.\\
The measurement points are simply timestamps of when the application reaches some points in the execution. An example of a measurement point within the Pi Component can be found in the appendix \ref{code:pi} at line \#3.\\

% \todo{We made changes to OpenDaVinci, we shall specify that here.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Pi Component}
% why is it calculating pi? 

The Pi Component is responsible for calculating the next digit of Pi until it reaches 80\% of its' designated time-slice. The remaining 20\% of the time-slice is spent sleeping. The rationale of why it is specifically 80\% is due to the ability to have a buffer for sleeping to simulate a realistic scenario of code running for a particular time of the time-slice. Further, an approach of limiting to a certain amount of pi-digits was investigated. However it would prove to be difficult to predict whether the amount of pi digits calculated would not occupy more than the specified time deadline. Therefore an approach to limit the pi calculation to a specific time of a time-slice was chosen as it provides a more controlled environment. The pi calculations are merely there to simulate some load and not to intrude on other components of the application, such as the overhead added by OpenDaVINCI and the accuracy of the system sleep. With the approach of limiting to pi-digits would be chosen, it may intrude on the actual overhead that the experiment sets out to measure.\\

%why 80%? why pi? which pi algorithm? measurement points 
See Appendix~\ref{code:pi}, on page ~\pageref{code:pi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Pi/IO Component}

Pi/IO Component is responsible for the measuring input/output in order to answer RQ2 (\ref{section:rqs}). The component extends the Pi Component by adding two additional factors to its time-slice execution. The factors are camera IO and disk IO. The code implementation of the camera component is a direct copy of code utilized by ReVeRe lab in a real-life scenario of a self-driving truck\footnote{https://github.com/chalmers-revere/opendlv}. This was copied to mimic real-life to ensure the relevance of the data captured. Furthermore, the code implementation for disk IO is also a direct copy used by ReVeRe lab for logging the system during runtime. Between these two additional factors, two measurement points are set to measure the overhead added by capturing an image and dumping that image to the disk.\\

See Appendix~\ref{code:pi-io}, on page ~\pageref{code:pi-io}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experimental Material}
% all experimental material and equipment should be described. all characteristics that might have an impact on the results should be mentioned here as formally as possible. 
In order for the experiment to begin, the target system needs to be prepared and configured with software. This section identifies the preparation of the target system to ensure reproducibility of the experiment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Preparing the Target System}
The experiment presented in this report will be executed on a AEC 6950\footnote{http://www.aaeon.com/en/p/fanless-embedded-computers-aec-6950/} embedded personal computer manufactured by Aaeon.   The hardware specification for the target system can be found in table~\ref{table:test}. 

\begin{table}[H]
\centering

\begin{tabular}{|l|l|}
\hline
\textbf{Component} & \textbf{Specification} 			\\ \hline
Processor          & Intel Core i7 3517UE 1.7 GHz 		\\ \hline
Memory             & 4GB DDR3 1333/1600 SODIMM          \\ \hline
Storage Device     & 2.5" SATA HDD x 1                  \\ \hline
Serial Interfaces  & \begin{tabular}[c]{@{}l@{}}USB type A x 2 for USB 2.0\\ USB type A x 2 for USB 3.0\\ DB-9 x 2 for RS-232/422/485 x 2\\ DB-9 x 4 for RS-232 x 4\\ Isolated Digital Input/Output x 10 pins (DI x 4, DO x 4)(3KV) \\ Isolated DB-9 x 2 for RS-232/422/485 x 2 (3KV, jumper selection)\end{tabular} \\ \hline
\end{tabular}
\caption{Target System Hardware Specification}
\label{table:test}
\end{table}

\subsubsection{Preparing the Operating System}
The operating system chosen for the experiment is Ubuntu Server 14.04.1 LTS (Long Term Support). Long term supported operating systems ensure that the operating system stays up to date with current software versions and that defects are attended to. The specific version for the operating system, mainline vanilla kernel and RT\_PREEMPT patch is found in table~\ref{table:execution-version}. All software packages installed on the target system is made possible through an offline package manager. Installation and configuration of all required software packages are executed by a script to ensure reproducibility each time the operating system is reinstalled. 

\begin{table}[h]
\begin{tabular}{|l|l|l|}
\hline
\textbf{Operating System} & \textbf{Mainline Kernel} & \textbf{RT\_PREEMPT Patch} \\ \hline
Ubuntu Server 14.04.1     & 3.18.25                  &  3.18.25-rt23               \\ \hline
\end{tabular}
\centering
\caption{Execution Enviroment Versioning}
\label{table:execution-version}
\end{table}

\subsubsection{Preparing the Linux Kernel}
The Linux vanilla kernel version 3.18.25 is chosen to be used in the experiment. The main motivation behind utilising this specific Linux kernel is that it is both supported by the RT\_PREEMPT patch as well as Docker. At the time of writing the RT\_PREEMPT patch for 3.18.25 is actively maintained and supported. A configuration file used by the Open Source Automation Development Lab \cite{OSADL} is used to patch the vanilla kernel with RT\_PREEMPT.

\subsubsection{Stressing the Target System}
\textit{Summary: The specific stress tool is still being finalised}



\subsection{Tasks}
The experimental units are tasked with capturing measurement points and sending the measurement data via serial communication where they are stored. The specific measurement points that is captured can be found in section~\ref{section:dependent}.


\subsection{Hypotheses, Parameters and Variables}
% there is a difference / there is no difference 
%$H_{0i_{j}}$
This section presents all hypotheses that will be analysed and answered in order to understand how the specified execution environments impact the performance of the real-time application.\\

The hypotheses to achieve goal one of the experiment are:
\begin{itemize}
% For RQ1 
\item $H_{01_{1}}$ - The deployment context has no impact on scheduling precision.
\item $H_{11_{1}}$ - The deployment context has an impact on scheduling precision.
\item $H_{01_{2}}$ - The Linux kernels used in the experiment has no impact on scheduling precision.
\item $H_{11_{2}}$ - The Linux kernels used in the experiment has an impact on scheduling precision.
\item $H_{01_{3}}$ - The execution environment has no impact on scheduling precision.
\item $H_{11_{3}}$ - The execution environment has an impact on scheduling precision.\\
\end{itemize}


The hypotheses to achieve goal two of the experiment are:
\begin{itemize}
% For RQ2
\item $H_{02_{1}}$ - The deployment context has no impact on camera IO performance.
\item $H_{12_{1}}$ - The deployment context has an impact on on camera IO performance.
\item $H_{02_{2}}$ - The Linux kernels used in the experiment has no impact on camera IO performance.
\item $H_{12_{2}}$ - The Linux kernels used in the experiment has an impact on camera IO performance.
\item $H_{02_{3}}$ - The execution environment has no impact on camera IO performance.
\item $H_{12_{3}}$ - The execution environment has an impact on camera IO performance.
\item $H_{02_{4}}$ - The deployment context has no impact on disk IO performance.
\item $H_{12_{4}}$ - The deployment context has an impact on disk IO performance.
\item $H_{02_{5}}$ - The Linux kernels used in the experiment has no impact on disk IO performance.
\item $H_{12_{5}}$ - The Linux kernels used in the experiment has an impact on disk IO performance.
\item $H_{02_{6}}$ - The execution environment has no impact on disk IO performance.
\item $H_{12_{6}}$ - The execution environment has an impact on disk IO performance.
\end{itemize}

\todo{define influence,disk IO performance,camera IO performance}

\subsubsection{Dependent Variables} \label{section:dependent}
%variable that is measured to ascertain whether the independent variable has an effect on the outcome
There exists three separate dependent variables that will be used for measuring how each is impacted by the independent variables. The dependent variables are namely; 1) \textit{scheduling precision}, 2) \textit{camera IO}, and 3) \textit{disk IO}. Where \textit{scheduling precision} refers to how accurately in terms of time the system performs the executions within the time-slice. Measured by timing the duration between four measurement points for the Pi Component and six points for the Pi/IO Component.\\ 

Figure \ref{pi_measure} displays the four measurement points of the Pi Component time-slice, where the duration between measurement points \#1 and \#2, and between \#3 and \#4 reveals the necessary overhead of OpenDaVinci. While the duration between \#4 and \#1 (next time-slice) reveals the sleep precision of the execution environment.\\

Figure \ref{piio_measure} displays the six measurement points of the Pi/IO Component time-slice, where the duration between measurement points \#2 and \#3 reveals the Camera IO performance of the execution environment. Duration between measurement points \#3 and \#4 reveals the Disk IO performance of the execution environment. Whereas the duration between \#2 and \#4 depicts the total IO performance of the executed time-slice. The remaining measurement points are the same points used for Pi Component.\\


\begin{figure}[ht]
\centering
     \includegraphics[width=1.0\textwidth]{./figure/measurement_points_pi.png}
      \caption{Measurement points for Pi scheduling precision.}
       \label{pi_measure}
\end{figure}

\begin{figure}[ht]
\centering
     \includegraphics[width=1.0\textwidth]{./figure/measurement_points_piio.png}
      \caption{Measurement points for IO performance.}
       \label{piio_measure}
\end{figure}

 \textit{Camera IO} refers to how much time is required for the application to capture an image from a camera. \textit{Disk IO} refers to how much time is required for the application to dump the image data to the disk. These three variables will be used separately to answer the two sets of hypotheses that addresses the two research goals. 

\subsubsection{Independent Variables}
%manipulated variable to influence dependent variable
The treatments that will be used for assessing the impact are the factors mentioned earlier, namely: 1) Kernel version (RT-preempt patch or Generic) and 2) Deployment context (Docker or natively). These variables will be the variables upon which the research questions will be answered.

\subsection{Design}
A Quasi experiment design is used since random assignment is not applicable in this case. The experimental units, being the Pi and Pi/IO components, are
formally categorized as two independent components. A Quasi experiment is useful when random assignment to treatment groups is impossible \cite{juristo2003lecture}. The experiment is not aimed to establish a cause and effect relationship, but rather an observation on how the experimental units perform.



\subsection{Procedure}
% exactly what happens to the participants from the moment they arrive to the moment they leave. Schedule for the experiment (how long did we run it for), how was the data collected and with what support (tools)
% used a script that automated the entire test
% boot system, rest for x ammount of time, disable networking start the supercomponent ... ... 

The execution of the experiment run is carried out by using a script to automate the entire process. The steps in which the script perform are:\\

\begin{enumerate}  
\item Boot the operating system and wait for five minutes.  
\item Start the \textit{supercomponent} of OpenDaVINCI.
\item Start the experimental unit and run for one hour.
\item On completion of the experimental unit, wait for five minutes.
\item Switch the kernel and reboot.\\ 
\end{enumerate}

While the data capturer is storing all measurement data received by the experiment units over serial communication. 

\subsection{Analysis Procedure}

To address both research questions and to ensure full coverage, the experiment results will be analysed through an ANOVA to understand the impact the different treatments have on the dependent variable.\\













