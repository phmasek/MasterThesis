%Analyse <..> for the purpose of <..> with respect to their <..> from the point of view of the <..> in the context of <..>
\iffalse \bibliography{include/backmatter/magnus,include/backmatter/philip} \fi
\chapter{Methodology}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experiment Planning}
% all information that is necessary to replicate the study 
In order to answer the research questions, an experiment is carried out following the guidelines for reporting experiments in software engineering \cite{Andreas}. All material for the experiment is available online\footnote{github.com/Pletron/ODVpi}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Goals}
% refine the main research questions, describe and motivate them to allow for traceability down to the hypotheses. 
%Does the respective execution context influence the scheduling precision of the respective application?
%Does the respective execution context influence the input/output performance of the respective application?
The aim of the experiment is to systematically evaluate the scheduling precision and input-output performance of the experimental units running in different execution environments with respect to the deployment context. The goals of the experiment is described in table~\ref{table:exp-goals}, where the experimental units, execution environment and system load is described further in this section.  

% execution environment: complete system 
% deployment context: docker non-docker 

\begin{table}[ht]
\begin{tabular}{l|p{12cm}}
Goal 1 & Analyse the scheduling precision of the Pi Component for the purpose of understanding how deterministic the system is with respect to the execution environment and system load. \\
Goal 2 & Analyse the input and output performance of the Pi/IO Component for the purpose of understanding how deterministic the system is with respect to the execution environment and system load.
\end{tabular}
\centering
\caption{Experiment Goals}
\label{table:exp-goals}
\end{table}


\subsubsection*{Execution Environment}
The execution environment describes the setting in which the execution of the experimental units take place. Specifically, the execution environment refers to all components that make up a complete system: the processors, operating system, software packages and so on. There are four execution environments used in this experiment. The execution environments are configured the same but with two main differences. The difference being (1) an alternation of two Linux kernels and (2) an alternation of the deployment context. In this case, the deployment context is running the experiment units bare-metal on the target system or running the experimental units in a Docker container. The execution environments are precisely specified in table~\ref{table:exe-env}, where the configuration of the execution environment is later described in section~\ref{section:exp-material}.


\begin{table}[h]
\begin{tabular}{l|p{14cm}}
1. & Running the experimental units natively on the target system running a mainline vanilla Linux kernel.                               \\
2. & Running the experimental units natively on the target system running a mainline Linux kernel patched with RT\_PREEMPT.              \\
3. & Running the experimental units in a Docker container on the target system running a mainline vanilla Linux kernel.                  \\
4. & Running the experimental units in a Docker container on the target system running a mainline Linux kernel patched with RT\_PREEMPT.
\end{tabular}
\centering
\caption{Execution Environments}
\label{table:exe-env}
\end{table}


\subsubsection*{System Load}
Submitting the target system to heavy load is required in order to (1) traverse as many code paths of the kernel as possible and (2) mimic the run-time load of a real-time system. Stress-ng \cite{stress-ng} is a user-space application that interacts with many components of the kernel. It can spawn a number of worker threads that perform useless tasks in order to apply load to the target system. The type of worker thread can vary from CPU load to disk intensive load. Applying heavy load to the target system enables the experiment to be executed in an environment that mimics a real-life scenario. One would expect a real-time system to consume 80\% of the system's resources, leaving a 20\% buffer for extreme circumstances to circumvent system overload. \\

The experiment is performed in two scenarios: applying no-load and apply high-load to the system. Having the two scenarios allows us to make a fair comparison by identifying how the experimental units perform in a perfect environment versus a more realistic environment.  

%Tracing through all possible code paths of the kernel is not an option to uncover how deterministic a system is. In order to get a reliable estimation, a tool is required to traverse as many of these as possible. Stress offers a way to induce several different kinds of system load, therefore it interacts with many components of the kernel and should be able to expose some of the longer code paths through the kernel. Stress is a user-space application that can spawn a number of worker threads that perform useless tasks with the only purpose of submitting the system on which it runs to heavy load. Putting the system under load also enables the experiment to be executed in an environment that mimics a real-life scenario. One would expect a computer system in production to run at 80\% load, leaving a 20\% buffer for extreme circumstances and to avoid overloading the system.  



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experimental Units}
\label{section:exp-units}
% participants (experimental units) need to be described in detail. Sampling strategy, the number of participants, the kind of participants and the population they were drawn from. 

The experimental units, codenamed Pi and Pi/IO, are realised by the open source development library OpenDaVINCI. Using OpenDaVINCI as a development architecture for the experimental units allows the experiment to mimic the middle-ware one can expect in a autonomous vehicle. The implementation of OpenDaVINCI has been altered to enable full measurement of the system during runtime. The measurement points are simply timestamps of when the application reaches specific points in the code base during run-time. The specific changes that were made to the OpenDaVINCI library are: \\

\begin{enumerate}
\item Included specific measurement points that captures the current time within OpenDaVINCI's source code.
\item The measurement of time is modified to nanosecond precision.
\item A function is included to write measurement data to a serial port.\\
\end{enumerate}

%Further extensions were made to make sure the measurements were as precise as possible by enabling nanosecond precision. Lastly, Timestamp was altered to enable writing the data of the measurement points to a serial port, the code added can be found in the appendix \ref{code:serialtime}.The measurement points are simply timestamps of when the application reaches some points in the execution. An example of a measurement point within the Pi Component can be found in the appendix \ref{code:pi} at line \#3.\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Pi Component}
The Pi Component is utilised for measuring scheduling precision in order to answer RQ1. The Pi Component is tasked with calculating the next digit of Pi until it reaches 80\% of its' designated time-slice. The remaining 20\% of the time-slice is spent sleeping. The rationale for why it is specifically 80\% is for the ability to have a buffer that is reserved for sleeping. An alternative approach to the Pi Component was investigated. Namely, limiting the pi algorithm to only calculate \textit{x} digits of pi instead of calculating pi for \textit{x} amount of time. This approach made it difficult to predict whether the amount of pi digits calculated would occupy more than the specified timing requirement. The approach to limit the amount of pi calculations to 80\% was chosen as it provides a more controlled environment. The algorithm that calculates pi, specifically the Leibniz formula \cite{leibniz}, is merely there to simulate some load. In the actual development of a autonomous vehicle, the pi algorithm would be replaced with logic that is useful. \\  


%The Pi Component is responsible for capturing data to measuring scheduling precision in order to answer RQ1. The Pi Component is tasked with calculating the next digit of Pi until it reaches 80\% of its' designated time-slice. The remaining 20\% of the time-slice is spent sleeping (\texttt{clock\_nanosleep}). The rationale of why it is specifically 80\% is due to the ability to have a buffer for sleeping to simulate a realistic scenario of code running for a particular time of the time-slice. An approach of limiting to a certain amount of pi-digits was investigated. However it would prove to be difficult to predict whether the amount of pi digits calculated would not occupy more than the specified time deadline. Therefore an approach to limit the pi calculation to a specific time of a time-slice was chosen as it provides a more controlled environment. The pi calculations are merely there to simulate some load and not to intrude on other components of the application, such as the overhead added by OpenDaVINCI and the accuracy of the system sleep. With the approach of limiting to pi-digits would be chosen, it may intrude on the actual overhead that the experiment sets out to measure.\\

See Appendix~\ref{code:pi}, on page ~\pageref{code:pi}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{Pi/IO Component}
The Pi/IO Component is utilised for measuring input and output performance in order to answer RQ2. The component is an extension of the Pi Component with two additional factors. These factors are reading an image from a web camera (input) and storing the image to disk (output). The code implementation of capturing an image from a camera is a direct copy from the open-source project OpenDLV. OpenDLV, at the time of writing, is software under development for the operation of an autonomous self-driving vehicle and is built upon OpenDaVINCI. Utilising source code from the OpenDLV project adds credibility to the experiment. Furthermore, the code implementation for storing an image to disk is also a direct copy from the OpenDLV project that is used for logging the system during runtime. In order to capture the specific performance measure of input and output, two measurement points are added to measure the overhead by capturing an image and storing it to disk. \\

%The Pi/IO Component is responsible for the measuring input/output performance in order to answer RQ2 (\ref{section:rqs}). The component extends the Pi Component by adding two additional factors to its time-slice execution. The factors are camera IO and disk IO. The code implementation of the camera component is a direct copy of code utilized by ReVeRe lab in a real-life scenario of a self-driving truck\footnote{https://github.com/chalmers-revere/opendlv}. This was copied to mimic real-life to ensure the relevance of the data captured. Furthermore, the code implementation for disk IO is also a direct copy used by ReVeRe lab for logging the system during runtime. Between these two additional factors, two measurement points are set to measure the overhead added by capturing an image and dumping that image to the disk.\\

See Appendix~\ref{code:pi-io}, on page ~\pageref{code:pi-io}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experimental Material}
\label{section:exp-material}
% all experimental material and equipment should be described. all characteristics that might have an impact on the results should be mentioned here as formally as possible. 
In order for the experiment to begin, the target system needs to be prepared and configured with software. This section identifies the preparation of the target systems' execution environment to ensure reproducibility of the experiment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\subsubsection*{Hardware}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Component} & \textbf{Specification} 			\\ \hline
Processor          & Intel Core i7 3517UE 1.7 GHz 		\\ \hline
Memory             & 4GB DDR3 1333/1600 SODIMM          \\ \hline
Storage Device     & 2.5" SATA HDD x 1                  \\ \hline
Serial Interfaces  & \begin{tabular}[c]{@{}l@{}}USB type A x 2 for USB 2.0\\ USB type A x 2 for USB 3.0\\ DB-9 x 2 for RS-232/422/485 x 2\\ DB-9 x 4 for RS-232 x 4\\ Isolated Digital Input/Output x 10 pins (DI x 4, DO x 4)(3KV) \\ Isolated DB-9 x 2 for RS-232/422/485 x 2 (3KV, jumper selection)\end{tabular} \\ \hline
\end{tabular}
\caption{Target System Hardware Specification}
\label{table:hardware}
\end{table}

\subsubsection*{Preparing the Operating System}
OS versions, Docker Aufs to Overlay
\subsubsection*{Preparing the Linux Kernels}

\subsubsection*{Docker Parameters}

\subsubsection*{Stressing the Target System}
\begin{center}\fbox{\parbox{11cm}{\texttt{stress-ng --cpu 2 --cpu-load 80 --cpu-method pi --sched fifo --sched-prio 48}}}\end{center}

\subsection{Tasks}
% what tasks have to be performed by the subjects 

The experimental units are tasked with capturing measurement points and sending the measurement data via serial communication where they are stored. The specific measurement points that is captured can be found in section~\ref{section:dependent}.



\subsection{Hypotheses, Parameters and Variables}
% there is a difference / there is no difference 
%$H_{0i_{j}}$
This section presents all hypotheses that will be analysed and answered in order to understand how the specified execution environments impact the performance of the real-time application.\\

\todo{disk IO refers to reading and writing to the disk}

The hypotheses to achieve goal one of the experiment are:
\begin{itemize}
% For RQ1 
\item $H_{01_{1}}$ - The deployment context has no impact on scheduling precision.
\item $H_{11_{1}}$ - The deployment context has an impact on scheduling precision.
\item $H_{01_{2}}$ - The Linux kernels used in the experiment has no impact on scheduling precision.
\item $H_{11_{2}}$ - The Linux kernels used in the experiment has an impact on scheduling precision.
\item $H_{01_{3}}$ - The execution environment has no impact on scheduling precision.
\item $H_{11_{3}}$ - The execution environment has an impact on scheduling precision.\\
\end{itemize}


The hypotheses to achieve goal two of the experiment are:
\begin{itemize}
% For RQ2
\item $H_{02_{1}}$ - The deployment context has no impact on camera IO performance.
\item $H_{12_{1}}$ - The deployment context has an impact on on camera IO performance.
\item $H_{02_{2}}$ - The Linux kernels used in the experiment has no impact on camera IO performance.
\item $H_{12_{2}}$ - The Linux kernels used in the experiment has an impact on camera IO performance.
\item $H_{02_{3}}$ - The execution environment has no impact on camera IO performance.
\item $H_{12_{3}}$ - The execution environment has an impact on camera IO performance.
\item $H_{02_{4}}$ - The deployment context has no impact on disk IO performance.
\item $H_{12_{4}}$ - The deployment context has an impact on disk IO performance.
\item $H_{02_{5}}$ - The Linux kernels used in the experiment has no impact on disk IO performance.
\item $H_{12_{5}}$ - The Linux kernels used in the experiment has an impact on disk IO performance.
\item $H_{02_{6}}$ - The execution environment has no impact on disk IO performance.
\item $H_{12_{6}}$ - The execution environment has an impact on disk IO performance.
\end{itemize}

%\todo{define influence,disk IO performance,camera IO performance}

\subsubsection*{Dependent Variables} \label{section:dependent}
%variable that is measured to ascertain whether the independent variable has an effect on the outcome
There exists three separate dependent variables that will be used for measuring how each is impacted by the independent variables. The dependent variables are namely; 1) \textit{scheduling precision}, 2) \textit{camera IO}, and 3) \textit{disk IO}. Where \textit{scheduling precision} refers to how accurately in terms of time the system performs the executions within the time-slice. Measured by timing the duration between four measurement points for the Pi Component and six points for the Pi/IO Component.\\ 

Figure \ref{pi_measure} displays the four measurement points of the Pi Component time-slice, where the duration between measurement points \#1 and \#2, and between \#3 and \#4 reveals the necessary overhead of OpenDaVinci. While the duration between \#4 and \#1 (next time-slice) reveals the sleep precision of the execution environment.\\

Figure \ref{piio_measure} displays the six measurement points of the Pi/IO Component time-slice, where the duration between measurement points \#2 and \#3 reveals the Camera IO performance of the execution environment. Duration between measurement points \#3 and \#4 reveals the Disk IO performance of the execution environment. Whereas the duration between \#2 and \#4 depicts the total IO performance of the executed time-slice. The remaining measurement points are the same points used for Pi Component.\\


\begin{figure}[ht]
\centering
     \includegraphics[width=1.0\textwidth]{./figure/measurement_points_pi.png}
      \caption{Measurement points for Pi scheduling precision.}
       \label{pi_measure}
\end{figure}

\begin{figure}[ht]
\centering
     \includegraphics[width=1.0\textwidth]{./figure/measurement_points_piio.png}
      \caption{Measurement points for IO performance.}
       \label{piio_measure}
\end{figure}

 \textit{Camera IO} refers to how much time is required for the application to capture an image from a camera. \textit{Disk IO} refers to how much time is required for the application to dump the image data to the disk. These three variables will be used separately to answer the two sets of hypotheses that addresses the two research goals. 

\subsubsection*{Independent Variables}
%manipulated variable to influence dependent variable
The treatments that will be used for assessing the impact are the factors mentioned earlier, namely: 1) Kernel version (RT-preempt patch or Generic) and 2) Deployment context (Docker or natively). These variables will be the variables upon which the research questions will be answered.

\subsection{Design}
A Quasi experiment design is used since random assignment is not applicable in this case. The experimental units, being the Pi and Pi/IO components, are formally categorized as two independent components. \todo{more details to come}



\subsection{Procedure}
% How will the experiment (i.e data collection) be performed? What instruments, materials, tools will be used and how

Running the 2 experimental units on all 4 execution enviroment, submitting each run to load and with no load (2), results in 16 experimental runs. 

Run at 100hz and 10hz 



The execution of the experiment run is carried out by using a script to automate the entire process. The steps in which the script perform are:\\

\begin{enumerate}  
\item Boot the operating system and wait for five minutes.  
\item Start the \textit{supercomponent} of OpenDaVINCI.
\item Start the experimental unit and run for one hour.
\item On completion of the experimental unit, wait for five minutes.
\item Switch the kernel and reboot.\\ 
\end{enumerate}

While the data capturer is storing all measurement data received by the experiment units over serial communication. 

\subsection{Analysis Procedure}
To address both research questions and to ensure full coverage, the experiment results will be analysed through an analysis of variance (ANOVA) to understand the impact the different treatments have on the dependent variable.\\









